rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Function to check if a field exists and is a non-empty string
    function isNonEmptyString(fieldName) {
      return fieldName in request.resource.data &&
             request.resource.data[fieldName] is string &&
             request.resource.data[fieldName].size() > 0;
    }

    // Function to check if a field is the server timestamp upon creation/update
    function isServerTimestamp(fieldName) {
      // Allow server timestamp on create or update
      return request.resource.data[fieldName] == request.time;
    }

     // Function to check if a field is a timestamp or null
    function isTimestampOrNull(fieldName) {
      return request.resource.data[fieldName] == null || request.resource.data[fieldName] is timestamp;
    }

    // Enhanced function to validate credit updates securely
    function isValidCreditUpdate() {
      let currentCredits = resource.data.credits;
      let newCredits = request.resource.data.credits;
      let lastCreditReset = request.resource.data.lastCreditReset;
      // Allow credit updates in these scenarios:
      // 1. Decrease by 1 (for message sending): current - 1
      // 2. Reset to 5 (daily reset): when new credits = 5
      // 3. Decrease from any amount to 0 (edge case handling)
      // If credits are being reset to 5, lastCreditReset must also be updated to server timestamp
      return (
        (newCredits == currentCredits - 1) ||
        (newCredits == 5 && lastCreditReset == request.time) ||
        (newCredits == 0) ||
        (newCredits >= 0 && newCredits <= 5)
      );
    }

    // Function to validate memory session data
    function isMemorySessionDataValid(data) {
      // Check required fields and types for memory sessions
      return data.summary is string && data.summary.size() > 0 &&
             data.summarizedAt == request.time && // Check for server timestamp placeholder on create
             data.sourceMessageIds is list && data.sourceMessageIds.size() > 0 &&
             (data.tokenCount == null || data.tokenCount is number) && // Allow optional token count
             (data.metadata == null || data.metadata is map); // Allow optional metadata field, ensure it's a map if present
    }

    // ==== User Profiles (/users/{userId}) ====
    match /users/{userId} {
      // Allow owner to read their profile
      allow read: if isOwner(userId);

      // Allow owner to create their profile document only if it doesn't exist yet
      // Validate required fields upon creation
      allow create: if isOwner(userId)
                      && isNonEmptyString('uid') && request.resource.data.uid == userId
                      && isNonEmptyString('email')
                      && isNonEmptyString('displayName') // Ensure display name is provided
                      && isNonEmptyString('providerId')
                      && request.resource.data.credits == 5
                      && request.resource.data.monthlyResets == 0
                      && isServerTimestamp('createdAt')
                      && isServerTimestamp('lastLoginAt')
                      && isServerTimestamp('lastCreditReset')
                      && isServerTimestamp('monthlyCycleStart');

      // Allow owner to update specific fields with strict validation
      allow update: if isOwner(userId)
                      // Prevent modification of critical immutable fields
                      && !('uid' in request.writeFields)
                      && !('email' in request.writeFields)
                      && !('providerId' in request.writeFields)
                      && !('createdAt' in request.writeFields)
                      // Validate credit updates to prevent artificial increases
                      && (!('credits' in request.writeFields) || isValidCreditUpdate())
                      // Validate other credit-related fields
                      && (!('monthlyResets' in request.writeFields) || 
                          (request.resource.data.monthlyResets is number && 
                           request.resource.data.monthlyResets >= 0 && 
                           request.resource.data.monthlyResets <= 6))
                      // Validate timestamp fields
                      && (!('lastCreditReset' in request.writeFields) || isServerTimestamp('lastCreditReset'))
                      && (!('monthlyCycleStart' in request.writeFields) || isServerTimestamp('monthlyCycleStart'))
                      && (!('lastLoginAt' in request.writeFields) || isServerTimestamp('lastLoginAt'))
                      && (!('lastActive' in request.writeFields) || isServerTimestamp('lastActive'))
                      // Validate optional fields
                      && (!('displayName' in request.writeFields) || request.resource.data.displayName is string)
                      && (!('photoURL' in request.writeFields) || 
                          request.resource.data.photoURL == null || request.resource.data.photoURL is string)
                      // Validate map fields
                      && (!('personaLastActive' in request.writeFields) || request.resource.data.personaLastActive is map)
                      && (!('personaLastSummaryTimestamp' in request.writeFields) || request.resource.data.personaLastSummaryTimestamp is map);

      // Disallow listing all users and deleting profiles
      allow list, delete: if false;
    }

    // ==== User Messages (/users/{userId}/messages/{messageId}) ====
    match /users/{userId}/messages/{messageId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId)
                        && isNonEmptyString('role') && request.resource.data.role in ['user', 'assistant']
                        && isNonEmptyString('content')
                        && isNonEmptyString('persona') // Assumes persona is always required for a message
                        && request.resource.data.createdAt == request.time;
        allow update, delete: if false;
    }

    // ==== Prevent listing of any subcollections under users (defense-in-depth) ====
    match /users/{userId}/{subcollection=**} {
      allow list: if false;
    }

    // ==== Per-Persona Summaries (/users/{userId}/personas/{personaId}/summaries/{summaryId}) ====
    match /users/{userId}/personas/{personaId}/summaries/{summaryId} {
        allow read: if isOwner(userId);
        allow create: if isOwner(userId)
                        && isNonEmptyString('summary')
                        && request.resource.data.createdAt == request.time; // Assuming timestamp field is createdAt
        allow update, delete: if false;
    }

    // ==== Per-Persona Session Metadata (/users/{userId}/personas/{personaId}/session/metadata) ====
    match /users/{userId}/personas/{personaId}/session/metadata {
        allow read: if isOwner(userId); // Changed from 'get' to 'read' for consistency
        allow create: if isOwner(userId)
                        && isTimestampOrNull('lastSummarizedMessageTimestamp');
        allow update: if isOwner(userId)
                        && request.writeFields.hasOnly(['lastSummarizedMessageTimestamp'])
                        && (request.resource.data.lastSummarizedMessageTimestamp == null || 
                            request.resource.data.lastSummarizedMessageTimestamp is timestamp);
        allow list, delete: if false;
    }

    // ==== Memory Sessions (/users/{userId}/personas/{personaId}/memory_sessions/{sessionId}) ====
    match /users/{userId}/personas/{personaId}/memory_sessions/{sessionId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId) && isMemorySessionDataValid(request.resource.data);
      allow update, delete: if false;
    }

    // Default deny for any unmatched paths
  } // End match /databases/{database}/documents

  // ==== Explicit default deny for all unmatched paths (defense-in-depth) ====
  match /{document=**} {
    allow read, write: if false;
  }
} // End service cloud.firestore

// *** Redundant/Unused functions removed from here ***